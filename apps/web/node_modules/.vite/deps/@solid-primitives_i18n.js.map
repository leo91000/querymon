{
  "version": 3,
  "sources": ["../../../../../node_modules/.pnpm/@solid-primitives+i18n@2.2.1_solid-js@1.9.9/node_modules/@solid-primitives/i18n/dist/index.js"],
  "sourcesContent": ["const isDict = (value) => value != null &&\n    ((value = Object.getPrototypeOf(value)), value === Array.prototype || value === Object.prototype);\nconst isRecordDict = (value) => value != null && Object.getPrototypeOf(value) === Object.prototype;\nfunction visitDict(flat_dict, dict, path) {\n    for (const [key, value] of Object.entries(dict)) {\n        const key_path = `${path}.${key}`;\n        flat_dict[key_path] = value;\n        isDict(value) && visitDict(flat_dict, value, key_path);\n    }\n}\n/**\n * Flatten a nested dictionary into a flat dictionary.\n *\n * This way each nested property is available as a flat key.\n *\n * @example\n * ```ts\n * const dict = {\n *   a: {\n *     foo: \"foo\",\n *     b: { bar: 1 }\n *   }\n * }\n *\n * const flat_dict = flatten(dict);\n *\n * flat_dict === {\n *   a: {\n *     foo: \"foo\",\n *     b: { bar: 1 }\n *   },\n *   \"a.foo\": \"foo\",\n *   \"a.b\": { bar: 1 },\n *   \"a.b.bar\": 1,\n * }\n * ```\n */\nexport function flatten(dict) {\n    const flat_dict = { ...dict };\n    for (const [key, value] of Object.entries(dict)) {\n        isDict(value) && visitDict(flat_dict, value, key);\n    }\n    return flat_dict;\n}\n/**\n * Prefix all *(own)* keys in the dictionary with the provided prefix.\n *\n * Useful for namespacing a dictionary when combining multiple dictionaries.\n *\n * @example\n * ```ts\n * const dict = {\n *   hello: \"hello\",\n *   goodbye: \"goodbye\",\n *   food: { meat: \"meat\" },\n * }\n *\n * const prefixed_dict = prefix(dict, \"greetings\");\n *\n * prefixed_dict === {\n *   \"greetings.hello\": \"hello\",\n *   \"greetings.goodbye\": \"goodbye\",\n *   \"greetings.food\": { meat: \"meat\" },\n * }\n * ```\n */\nexport const prefix = (dict, prefix) => {\n    prefix += \".\";\n    const result = {};\n    for (const [key, value] of Object.entries(dict)) {\n        result[prefix + key] = value;\n    }\n    return result;\n};\n/**\n * Identity function that returns the same string branded as {@link Template} with the arguments needed to resolve the template.\n *\n * @example\n * ```ts\n * const template = i18n.template<{ name: string }>(\"hello {{ name }}!\");\n *\n * // same as\n * const template = \"hello {{ name }}!\" as Template<{ name: string }>;\n * ```\n */\nexport const template = (source) => source;\n/**\n * Simple template resolver that replaces `{{ key }}` with the value of `args.key`.\n *\n * @example\n * ```ts\n * resolveTemplate(\"hello {{ name }}!\", { name: \"John\" });\n * // => \"hello John!\"\n * ```\n */\nexport const resolveTemplate = (string, args) => {\n    if (args)\n        for (const [key, value] of Object.entries(args))\n            string = string.replace(new RegExp(`{{\\\\s*${key}\\\\s*}}`, \"g\"), value);\n    return string;\n};\n/**\n * Template resolver that does nothing. It's used as a fallback when no template resolver is provided.\n */\nexport const identityResolveTemplate = (v => v);\nexport function translator(dict, resolveTemplate = identityResolveTemplate) {\n    return (path, ...args) => {\n        if (path[0] === \".\")\n            path = path.slice(1);\n        const value = dict()?.[path];\n        switch (typeof value) {\n            case \"function\":\n                return value(...args);\n            case \"string\":\n                return resolveTemplate(value, args[0]);\n            default:\n                return value;\n        }\n    };\n}\nexport function scopedTranslator(translator, scope) {\n    return (path, ...args) => translator(`${scope}.${path}`, ...args);\n}\nexport function chainedTranslator(init_dict, translate, path = \"\") {\n    const result = { ...init_dict };\n    for (const [key, value] of Object.entries(init_dict)) {\n        const key_path = `${path}.${key}`;\n        result[key] = isRecordDict(value)\n            ? chainedTranslator(value, translate, key_path)\n            : (...args) => translate(key_path, \n            // @ts-expect-error\n            ...args);\n    }\n    return result;\n}\nexport function proxyTranslator(translate, path = \"\") {\n    return new Proxy(translate.bind(void 0, path), new Traps(translate, path));\n}\nclass Traps {\n    translate;\n    path;\n    constructor(translate, path) {\n        this.translate = translate;\n        this.path = path;\n    }\n    get(target, prop) {\n        if (typeof prop !== \"string\")\n            return Reflect.get(target, prop);\n        return proxyTranslator(this.translate, `${this.path}.${prop}`);\n    }\n    has(target, prop) {\n        if (typeof prop !== \"string\")\n            return Reflect.has(target, prop);\n        return proxyTranslator(this.translate, `${this.path}.${prop}`) !== undefined;\n    }\n    getOwnPropertyDescriptor(target, prop) {\n        if (typeof prop !== \"string\")\n            return Reflect.getOwnPropertyDescriptor(target, prop);\n        return {\n            enumerable: true,\n            get: () => proxyTranslator(this.translate, `${this.path}.${prop}`),\n        };\n    }\n}\n"],
  "mappings": "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",
  "names": ["prefix", "resolveTemplate", "translator"]
}
